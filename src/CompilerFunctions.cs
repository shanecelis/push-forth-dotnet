/* Original code Copyright (c) 2018 Shane Celis[1]
   Licensed under the MIT License[2]

   Original code posted here[3].

   This comment generated by code-cite[4].

   [1]: https://github.com/shanecelis
   [2]: https://opensource.org/licenses/MIT
   [3]: https://github.com/shanecelis/push-forth-dotnet/
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;

namespace PushForth {

public static class CompilerFunctions {
  public static int One() => 1;
  public static object Car(Stack s) => s.Car();
  public static Stack Cdr(Stack s) => s.Cdr(); 
  public static int Count(Stack s) => s.Count;
  public static Stack Unit(object o) {
    var s = new Stack();
    s.Push(o);
    return s;
  }

  // The order of the arguments is backwards here.
  public static Stack Cons(Stack s, object o) {
    s.Push(o);
    return s;
  }
}

public static class GenericInstructions {
  /**
    If the first argument is a Stack, it is given the data stack.

    If the instruction doesn't use the stack but wants a Stack s from the data
    stack, it must have a signature like this:

    int Depth<T>(Stack data, Stack s)
   */
  public static int Depth<T>(Stack s) {
    int count = 0;
    foreach (var x in s)
      if (x is T)
        count++;
    return count;
  }
}

}
