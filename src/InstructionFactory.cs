/* Original code Copyright (c) 2018 Shane Celis[1]
   Licensed under the MIT License[2]

   Original code posted here[3].

   This comment generated by code-cite[4].

   [1]: https://github.com/shanecelis
   [2]: https://opensource.org/licenses/MIT
   [3]: https://github.com/shanecelis/push-forth-dotnet/
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;

namespace PushForth {

public interface FuncFactory<out T> {
  // These are just naked stack handlers.
  // Hmm... These are the only things I really need.
  T Operation(Func<Stack, Stack> func,
              IEnumerable<Type> inputTypes,
              IEnumerable<Type> outputTypes);

  T Operation(Action<Stack> action,
              IEnumerable<Type> inputTypes,
              IEnumerable<Type> outputTypes);

  // T Nullary<X>(Func<X> func);
  // T Unary<X,Y>(Func<X,Y> func);
  // T Binary<X,Y,Z>(Func<X,Y,Z> func);
  // T Trinary<X,Y,Z,W>(Func<X,Y,Z,W> func);

  // T Nullary<X>(Func<Stack,X> func);
  // T Unary<X,Y>(Func<Stack,X,Y> func);
  // T Binary<X,Y,Z>(Func<Stack,X,Y,Z> func);
  // T Trinary<X,Y,Z,W>(Func<Stack,X,Y,Z,W> func);

  // T Nullary(Action action);
  // T Unary<X>(Action<X> action);
  // T Binary<X,Y>(Action<X,Y> action);
  // T Trinary<X,Y,Z>(Action<X,Y,Z> action);

  // T Nullary(Action<Stack> action);
  // T Unary<X>(Action<Stack,X> action);
  // T Binary<X,Y>(Action<Stack,X,Y> action);
  // T Trinary<X,Y,Z>(Action<Stack,X,Y,Z> action);
}

public class FuncFactoryAdapter<S,T> : FuncFactory<T> {
  FuncFactory<S> factory;
  Func<S,T> converter;

  public FuncFactoryAdapter(FuncFactory<S> factory,
                            Func<S,T> converter) {
    this.factory = factory;
    this.converter = converter;
  }

  public T Operation(Func<Stack,Stack> func,
                     IEnumerable<Type> inputTypes,
                     IEnumerable<Type> outputTypes)
    => converter(factory.Operation(func, inputTypes, outputTypes));
  public T Operation(Action<Stack> action,
                     IEnumerable<Type> inputTypes,
                     IEnumerable<Type> outputTypes)
    => converter(factory.Operation(action, inputTypes, outputTypes));
}

public static class FuncFactoryExtensions {

  public static FuncFactory<Y> Compose<X,Y>(this FuncFactory<X> factory,
                                            Func<X,Y> converter) {
    return new FuncFactoryAdapter<X,Y>(factory, converter);
  }

  /* XXX Maybe should just be rolled into a ConvenienceFactory, but for now
     this'll do.
   */
  public static T Nullary<T,X>(this FuncFactory<T> factory,
                               Func <X> func)
    => factory.Operation((stack) => {
        stack.Push(func());
      },
      Type.EmptyTypes,
      new [] { typeof(X) });

  public static T Unary<T,X,Y>(this FuncFactory<T> factory,
                      Func <X,Y> func) {
    return factory.Operation((stack) => {
        stack.Push(func((X) stack.Pop()));
      }, new [] { typeof(X) },
      new [] { typeof(Y) });
  }

  public static T Binary<T,X,Y,Z>(this FuncFactory<T> factory,
                         Func <X,Y,Z> func) {
    return factory.Operation((stack) => {
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        stack.Push(func(x, y));
      }, new [] { typeof(X), typeof(Y) },
      new [] { typeof(Z) });
  }
  public static T Trinary<T,X,Y,Z,W>(this FuncFactory<T> factory,
                            Func <X,Y,Z,W> func) {
    return factory.Operation((stack) => {
        var z = (Z) stack.Pop();
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        stack.Push(func(x, y, z));
      }, new [] { typeof(X), typeof(Y), typeof(Z) },
      new [] { typeof(W) });
  }

  public static T Nullary<T,X>(this FuncFactory<T> factory,
                             Func <Stack,X> func) {
    return factory.Operation((stack) => {
        stack.Push(func(stack));
      },
      Type.EmptyTypes,
      new [] { typeof(X) });
  }

  public static T Unary<T,X,Y>(this FuncFactory<T> factory,
                               Func <Stack,X,Y> func) {
    return factory.Operation((stack) => {
        stack.Push(func(stack, (X) stack.Pop()));
      }, new [] { typeof(X) },
      new [] { typeof(Y) });
  }

  public static T Binary<T,X,Y,Z>(this FuncFactory<T> factory,
                         Func <Stack,X,Y,Z> func) {
    return factory.Operation((stack) => {
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        stack.Push(func(stack, x, y));
      }, new [] { typeof(X), typeof(Y) },
      new [] { typeof(Z) });
  }
  public static T Trinary<T,X,Y,Z,W>(this FuncFactory<T> factory,
                            Func <Stack,X,Y,Z,W> func) {
    return factory.Operation((stack) => {
        var z = (Z) stack.Pop();
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        stack.Push(func(stack, x, y, z));
      }, new [] { typeof(X), typeof(Y), typeof(Z) },
      new [] { typeof(W) });
  }

  public static T Nullary<T>(this FuncFactory<T> factory,
                             Action func) {
    return factory.Operation((_) => {
        func();
      },
      Type.EmptyTypes,
      Type.EmptyTypes);
  }

  public static T Unary<T,X>(this FuncFactory<T> factory,
                             Action<X> func) {
    return factory.Operation((stack) => {
        func((X) stack.Pop());
      },
      new [] { typeof(X) },
      Type.EmptyTypes);
  }

  public static T Binary<T,X,Y>(this FuncFactory<T> factory,
                                Action<X,Y> func) {
    return factory.Operation((stack) => {
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        func(x, y);
      },
      new [] { typeof(X), typeof(Y) },
      Type.EmptyTypes);
  }
  public static T Trinary<T,X,Y,Z>(this FuncFactory<T> factory,
                                   Action<X,Y,Z> func) {
    return factory.Operation((stack) => {
        var z = (Z) stack.Pop();
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        func(x, y, z);
      },
      new [] { typeof(X), typeof(Y), typeof(Z) },
      Type.EmptyTypes);
  }

  public static T Nullary<T>(this FuncFactory<T> factory,
                             Action<Stack> func) {
    return factory.Operation((stack) => {
        func(stack);
      }, Type.EmptyTypes, Type.EmptyTypes);
  }

  public static T Unary<T,X>(this FuncFactory<T> factory,
                    Action<Stack, X> func) {
    return factory.Operation((stack) => {
        func(stack, (X) stack.Pop());
      }, new [] { typeof(X) }, Type.EmptyTypes);
  }

  public static T Binary<T,X,Y>(this FuncFactory<T> factory,
                                Action<Stack, X,Y> func) {
    return factory.Operation((stack) => {
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        func(stack, x, y);
      },
      new [] { typeof(X), typeof(Y) },
      Type.EmptyTypes);
  }
  public static T Trinary<T,X,Y,Z>(this FuncFactory<T> factory,
                                   Action<Stack, X,Y,Z> func) {
    return factory.Operation((stack) => {
        var z = (Z) stack.Pop();
        var y = (Y) stack.Pop();
        var x = (X) stack.Pop();
        func(stack, x, y, z);
      },
      new [] { typeof(X), typeof(Y), typeof(Z) },
      Type.EmptyTypes);
  }

  public static T FromMethod<T>(this FuncFactory<T> factory,
                                MethodInfo methodInfo) {
    if (methodInfo.IsGenericMethodDefinition) {
      // XXX Bad code smell.
      return (T) (object) new GenericMethodInstruction<T>(factory, methodInfo);
    }

    var parameters = methodInfo.GetParameters();
    bool stackFirstParameter = parameters.Any() && parameters[0].ParameterType == typeof(Stack);
    return factory.Operation(stack => {
        int count = parameters.Length;
        var args = new Object[count];
        for (int i = 0; i < count - 1; i++)
          args[count - 1 - i] = stack.Pop();
        // if (stackFirstParameter)
          args[0] = stackFirstParameter ? stack : stack.Pop();
        // else
        //   args[0] = stack.Pop();
        // Console.WriteLine("from method invoked");
        var result = methodInfo.Invoke(null, args);
        if (methodInfo.ReturnType != typeof(void))
          stack.Push(result);
      },
      stackFirstParameter
      ? parameters.Skip(1).Select(pi => pi.ParameterType)
      : parameters.Select(pi => pi.ParameterType),
      methodInfo.ReturnType != typeof(void) ? new [] { methodInfo.ReturnType } : Type.EmptyTypes);
  }
}

}
