/* Original code Copyright (c) 2018 Shane Celis[1]
   Licensed under the MIT License[2]

   Original code posted here[3].

   This comment generated by code-cite[4].

   [1]: https://github.com/shanecelis
   [2]: https://opensource.org/licenses/MIT
   [3]: https://github.com/shanecelis/push-forth-dotnet/
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using OneOf;

namespace PushForth {

/** Wraps an instruction such that mistyped arguments are _reordered_ and lack
    of arguments causes noops.
 */
public class PolymorphicInstruction : Instruction {
  IEnumerable<TypedInstruction> instructions;
  public bool tryBestFit = false;
  public PolymorphicInstruction(IEnumerable<TypedInstruction> instructions) {
    this.instructions = instructions;
    CheckInstructions();
  }

  void CheckInstructions() {
    var inputCount = instructions.First().inputTypes.Count();
    var outputCount = instructions.First().outputTypes.Count();
    foreach(var instruction in instructions.Skip(1)) {
      if (inputCount != instruction.inputTypes.Count())
        throw new Exception("Must have same number of inputTypes.");
      if (outputCount != instruction.outputTypes.Count())
        throw new Exception("Must have same number of outputTypes.");
    }
  }

  public virtual Stack Apply(Stack stack) {
    var acceptedArguments = new Stack();
    var binding = new Dictionary<string, Type>();
    Instruction foundInstruction = null;
    int[] acceptedArgumentsCount = new int[instructions.Count()];
    int i = 0;
    foreach (var instruction in instructions) {
      acceptedArguments.Clear();
      binding.Clear();
      IEnumerator stackContents = stack.GetEnumerator();
      foreach (Type consume in instruction.inputTypes) {
        if (! stackContents.MoveNext()) {
          // Not enough elements.
          // break;
          goto notFound;
          // return NotEnoughElements(stack, acceptedArguments);
        }
        object o = stackContents.Current;
        var t = o.GetType();
        Type consumeType = consume;
        // if (t == consume) {
        if (Variable.IsVariableType(consume)) {
          // XXX What is going on here?
          // We accept it. But we should track that it now means this type
          // and fail it it changes.
          var v = Variable.Instantiate(consume);
          if (binding.TryGetValue(v.name, out Type vType)) {
            consumeType = vType;
          } else {
            binding.Add(v.name, t);
            consumeType = t;
          }
        }

        if (consumeType.IsAssignableFrom(t)) {
          acceptedArgumentsCount[i]++;
          acceptedArguments.Push(o);
        } else {
          goto notFound;
          // break;
        }
      }
      foundInstruction = instruction;
    notFound:
      ;
      i++;
    }
    // Then run the real instruction.
    if (foundInstruction != null)
      return foundInstruction.Apply(stack);
    else {
      if (! tryBestFit)
        throw new Exception($"Unable to find an instruction that matches the types.");
      else {
        var max = acceptedArgumentsCount.Max();
        if (max == 0) {
          // There is no best fit for this instruction. Let's just move the top
          // argument away.
          if (stack.Any()) {
            var code = new Stack();
            code.Push(stack.Pop());
            code.Push(this);
            stack.Push(new Continuation(code));
            return stack;
          } else {
            // Drop the instruction.
            return stack;
          }
        } else {
          for (int j = 0; j < acceptedArgumentsCount.Length; j++) {
            if (acceptedArgumentsCount[j] == max) {
              var bestInstruction = instructions.ToArray()[j];
              return bestInstruction.Apply(stack);
            }
          }
          throw new Exception("Unable to find best fitting instruction.");
        }
      }
    }
  }

}

}
