/* Original code Copyright (c) 2018 Shane Celis[1]
   Licensed under the MIT License[2]

   Original code posted here[3].

   This comment generated by code-cite[4].

   [1]: https://github.com/shanecelis
   [2]: https://opensource.org/licenses/MIT
   [3]: https://github.com/shanecelis/push-forth-dotnet/
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using OneOf;

namespace PushForth {

/** Wraps an instruction such that mistyped arguments are _reordered_ and lack
    of arguments causes noops.
 */
public class PolymorphicInstruction : Instruction {
  IEnumerable<TypedInstruction> instructions;
  public PolymorphicInstruction(IEnumerable<TypedInstruction> instructions) {
    this.instructions = instructions;
  }

  public virtual Stack Apply(Stack stack) {
    var acceptedArguments = new Stack();
    var binding = new Dictionary<string, Type>();
    Instruction foundInstruction = null;
    foreach (var instruction in instructions) {
      acceptedArguments.Clear();
      binding.Clear();
      IEnumerator stackContents = stack.GetEnumerator();
      foreach (Type consume in instruction.inputTypes) {
        if (! stackContents.MoveNext()) {
          // Not enough elements.
          // break;
          goto notFound;
          // return NotEnoughElements(stack, acceptedArguments);
        }
        object o = stackContents.Current;
        var t = o.GetType();
        Type consumeType = consume;
        // if (t == consume) {
        if (Variable.IsVariableType(consume)) {
          // XXX What is going on here?
          // We accept it. But we should track that it now means this type
          // and fail it it changes.
          var v = Variable.Instantiate(consume);
          if (binding.TryGetValue(v.name, out Type vType)) {
            consumeType = vType;
          } else {
            binding.Add(v.name, t);
            consumeType = t;
          }
        }

        if (consumeType.IsAssignableFrom(t)) {
          acceptedArguments.Push(o);
        } else {
          goto notFound;
          // break;
        }
      }
      foundInstruction = instruction;
    notFound:
      ;
    }
    // Then run the real instruction.
    if (foundInstruction != null)
      return foundInstruction.Apply(stack);
    else
      throw new Exception($"Unable to find an instruction that matches the types.");
  }

}

}
