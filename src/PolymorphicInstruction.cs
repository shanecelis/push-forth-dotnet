/* Original code Copyright (c) 2018 Shane Celis[1]
   Licensed under the MIT License[2]

   Original code posted here[3].

   This comment generated by code-cite[4].

   [1]: https://github.com/shanecelis
   [2]: https://opensource.org/licenses/MIT
   [3]: https://github.com/shanecelis/push-forth-dotnet/
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using OneOf;

namespace PushForth {

/**
   Represents overloaded instructions which require different types. For
   instance, one can represent a "+" instruction that works for integers,
   floating-point numbers, and strings like so:

   ```cs
   var addInt = StrictInstruction.factory.Binary((int a, int b) => a + b);
   var addFloat = StrictInstruction.factory.Binary((float a, float b) => a + b);
   var addString = StrictInstruction.factory.Binary((string a, string b) => a + b);

   var addPoly = new PolymorphicInstruction(new [] { addInt, addFloat, addString });
   ```
 */
public class PolymorphicInstruction : Instruction {
  IEnumerable<TypedInstruction> instructions;
  /** XXX rename to strict?

   */
  public bool tryBestFit = false;
  public PolymorphicInstruction(IEnumerable<TypedInstruction> instructions) {
    this.instructions = instructions;
    CheckInstructions();
  }

  void CheckInstructions() {
    var inputCount = instructions.First().inputTypes.Count();
    var outputCount = instructions.First().outputTypes.Count();
    foreach(var instruction in instructions.Skip(1)) {
      if (inputCount != instruction.inputTypes.Count())
        throw new Exception("Must have same number of inputTypes.");
      if (outputCount != instruction.outputTypes.Count())
        throw new Exception("Must have same number of outputTypes.");
    }
  }

  public virtual Stack Apply(Stack stack) {
    var acceptedArguments = new Stack();
    var binding = new Dictionary<string, Type>();
    Instruction foundInstruction = null;
    int[] acceptedArgumentsCount = new int[instructions.Count()];
    int i = 0;
    foreach (var instruction in instructions) {
      acceptedArguments.Clear();
      binding.Clear();
      IEnumerator stackContents = stack.GetEnumerator();
      foreach (Type consume in instruction.inputTypes) {
        if (! stackContents.MoveNext()) {
          // Not enough elements.
          // break;
          if (tryBestFit)
            return stack;
          else
            throw new Exception("Not enough arguments.");
          // goto notFound;
          // return NotEnoughElements(stack, acceptedArguments);
        }
        object o = stackContents.Current;
        var t = o.GetType();
        Type consumeType = consume;
        // if (t == consume) {
        if (Variable.IsVariableType(consume)) {
          // XXX What is going on here?
          // We accept it. But we should track that it now means this type
          // and fail it it changes.
          var v = Variable.Instantiate(consume);
          if (binding.TryGetValue(v.name, out Type vType)) {
            consumeType = vType;
          } else {
            binding.Add(v.name, t);
            consumeType = t;
          }
        }

        if (consumeType.IsAssignableFrom(t)) {
          acceptedArgumentsCount[i]++;
          acceptedArguments.Push(o);
        } else {
          goto notFound;
          // break;
        }
      }
      foundInstruction = instruction;
      // break;
    notFound:
      ;
      i++;
    }
    // Then run the real instruction.
    if (foundInstruction != null)
      return foundInstruction.Apply(stack);
    else {
      if (! tryBestFit)
        throw new Exception($"Unable to find an instruction that matches the types.");
      else {
        var max = acceptedArgumentsCount.Max();
        // We're going to do a little reordering of the first argument that
        // doesn't match the max number of arguments.
        var temp = new Stack();
        // Capture the good arguments.
        for (int j = 0; j < max; j++)
          temp.Push(stack.Pop());
        // Create a continuation for the bad argument.
        var code = new Stack();
        code.Push(stack.Pop());
        code.Push(this);
        // Push the good arguments back onto the stack.
        while (temp.Any())
          stack.Push(temp.Pop());
        stack.Push(new Continuation(code));
        return stack;
      }
    }
  }

}

}
